# 报告2：实现《基本实验》所需代码修改分析

## 1. 核心分析

`基本实验.md` 文件为项目提供了明确的、从数据到评估的端到端执行方案。它不仅确认了我们在《报告1》中发现的“集成缺口”，还提出了更高的功能要求，包括多种对比算法、不确定性场景生成和在线模型更新等。

**结论**：现有代码库是一个优秀的**脚手架**，但要实现《基本实验》中描述的任何一个有意义的用例，都必须进行**实质性的重构和功能开发**。核心任务是将离散的、经过单元测试的模块（如优化模型）真正地集成到顶层仿真循环中，并增加对多种算法策略和不确定性处理的支持。

---

## 2. 主要差距分析 (Gaps Analysis)

以下是《基本实验》要求与当前代码现状之间的主要差距：

#### **差距 1：核心集成 — 仿真器未调用优化模型 (最关键)**
*   **现状**: `sim/runner.py` 中的求解器是简化的代数占位符，不执行任何实际的电力系统优化。
*   **要求**: 仿真器在每个时间步必须能调用 `opt/` 目录下的 Pyomo 模型，求解一个完整的 NMPC 问题，并将结果应用到系统中。

#### **差距 2：算法灵活性 — 缺乏多种控制策略**
*   **现状**: 代码只有一个基于 ADMM 的分布式协调框架的雏形。
*   **要求**: `runner` 必须支持至少 5 种算法（B0-B3, Our），包括集中式、分布式、带/不带 TI 包络等。这要求一个灵活的控制器切换机制。

#### **差距 3：不确定性建模 — 无法生成预测场景**
*   **现状**: `src/sim/forecast.py` 只有简单的持平/移动平均预测。
*   **要求**: 需要实现 `sample_forecast(truth, σ, ρ, horizon)` 函数，能根据真实值、误差大小（σ）和相关性（ρ）生成多组随机的预测轨迹，这是进行鲁棒性研究（TI包络、全场景鲁棒）的基础。

#### **差距 4：关键新功能 — 轨迹无关(TI)包络缺失**
*   **现状**: 项目中没有 TI 包络的相关代码。
*   **要求**: 需要从零创建 `ti_envelope.py` 模块，实现从多场景预测中计算包络（上下界），并能将这些包络作为约束应用到 Pyomo 模型中。

#### **差距 5：模型增强 — 静态模型无法满足动态需求**
*   **现状**: Pyomo 模型是静态的，灵敏度计算也是一次性的。
*   **要求**: 
    1.  **灵敏度在线更新**: `dso/network.py` 需要支持在线、周期性地重新计算灵敏度矩阵。
    2.  **模型扩展**: Pyomo 模型可能需要增加对储能（SOC）、可调负荷等更多设备的支持。

#### **差距 6：协调机制单一**
*   **现状**: 仅有 ADMM 的框架。
*   **要求**: 实验计划建议从“价格协调”起步，或至少作为 ADMM 的备选项。这意味着 `coord` 模块需要扩展。

---

## 3. 代码修改实施计划

为了弥补上述差距，我建议采用以下分步实施计划。这个计划旨在将现有代码重构为一个灵活、可扩展的实验平台。

### **第一步：重构控制器与仿真器接口 (解耦)**

这是最重要的一步，目的是让 `runner` 可以调用不同的算法。

1.  在 `src/nmpc/` 目录下创建一个 `controller.py`（如果已有则重构），定义一个抽象基类：
    ```python
    from abc import ABC, abstractmethod

    class BaseController(ABC):
        @abstractmethod
        def step(self, current_state: dict, forecasts: dict) -> dict:
            """Run one step of the NMPC control logic."""
            pass
    ```
2.  为每个算法创建一个具体的控制器类，继承 `BaseController`。例如：
    *   `src/nmpc/centralized.py` -> `CentralizedNMPC(BaseController)`
    *   `src/nmpc/distributed.py` -> `DistributedNMPC(BaseController)` (包含 ADMM 逻辑)
    *   `src/nmpc/greedy.py` -> `GreedyController(BaseController)` (用于 B0 基线)
3.  修改 `sim/runner.py`，在初始化时根据配置文件中的算法选择（如 `cfg['algorithm']`），创建一个对应的控制器实例。在主循环中，只需调用 `controller.step(...)`。

### **第二步：实现完整的 Pyomo 模型集成**

这一步将填补核心集成缺口。

1.  在 `src/opt/` 目录中，创建包装函数，例如 `solve_full_dso_nmpc`。
2.  此函数负责：
    a. 接收当前状态和预测数据。
    b. 调用 `build_dso_model` 构建 Pyomo 模型。
    c. 将预测数据、ADMM 协调变量等作为参数（`pyo.Param`）或变量边界（`.fix()`）更新到模型中。
    d. 调用 `solve_dso_model` 求解。
    e. 提取并返回结果。
3.  在 `DistributedNMPC` 控制器（来自第一步）的 `step` 方法中，将 ADMM 循环内的占位符求解器替换为对上述 `solve_full_dso_nmpc` 和 `solve_full_tso_nmpc` 的调用。

### **第三步：实现不确定性场景生成**

1.  扩充 `src/sim/forecast.py`。
2.  实现 `sample_forecast(truth, sigma, rho, horizon, num_scenarios)` 函数。该函数可以使用 AR(1) 模型或类似方法，在真实曲线 `truth` 的基础上生成 `num_scenarios` 组带有关联噪声的预测序列。

### **第四步：开发 TI 包络模块**

1.  创建新文件 `src/coord/ti_envelope.py`。
2.  实现 `compute_envelope(scenarios: np.ndarray)` 函数，它接收一个 `(num_scenarios, horizon, num_nodes)` 形状的数组，并返回每个时间步、每个节点的功率/电压上下界。
3.  实现 `apply_envelope_to_model(model: pyo.ConcreteModel, envelope: dict)` 函数。该函数会遍历 Pyomo 模型，并将 `envelope` 中的上下界添加为模型约束。
4.  在 `DistributedNMPC` 控制器中，当 `cfg['ti_envelope']['enabled']` 为 `True` 时，在构建 Pyomo 模型后、求解模型前，调用 `apply_envelope_to_model`。

### **第五步：更新配置和主流程**

1.  扩展 `src/utils/config.py` 或在使用配置的地方，以支持 `基本实验.md` 中定义的所有新参数（如 `ti_envelope`, `dist_opt` 等）。
2.  修改 `sim/runner.py` 的主循环，以实现灵敏度矩阵的周期性更新（如果 `cfg['sensitivity']['update_every']` > 0）。

---

## 4. 总结

将现有代码库改造为能够执行《基本实验》的平台是一项系统性工程，但并非遥不可及。当前清晰的模块化设计为您打下了良好的基础。上述实施计划提供了一条从**解耦**、到**集成**、再到**功能增强**的清晰路径。完成这些修改后，您的代码库将成为一个强大、灵活且可重复的计算实验平台，足以支撑一篇高水平的学术论文。